<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Defining NLME Models · Pumas</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Pumas</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../../tutorials/introduction/">Introduction to Pumas</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="../overview/">Overview of Pumas</a></li><li class="current"><a class="toctext" href>Defining NLME Models</a><ul class="internal"><li><a class="toctext" href="#The-@model-DSL-1">The <code>@model</code> DSL</a></li><li><a class="toctext" href="#The-PumasModel-Function-Based-Interface-1">The PumasModel Function-Based Interface</a></li></ul></li><li><a class="toctext" href="../doses_subjects_populations/">Dosage Regimens, Subjects, and Populations</a></li><li><a class="toctext" href="../simulation/">Simulation of Pumas Models</a></li><li><a class="toctext" href="../estimation/">Estimating Parameters of Pumas Models</a></li><li><a class="toctext" href="../nca/">Noncompartmental Analysis (NCA)</a></li><li><a class="toctext" href="../faq/">Frequently Asked Questions (FAQ)</a></li></ul></li><li><span class="toctext">Model Components</span><ul><li><a class="toctext" href="../../model_components/domains/">Domains</a></li><li><a class="toctext" href="../../model_components/dosing_control/">Dosing Control Parameters (DCP)</a></li><li><a class="toctext" href="../../model_components/dynamical_types/">Dynamical Problem Types</a></li></ul></li><li><span class="toctext">Diagnostics</span><ul><li><a class="toctext" href="../../analysis/diagnostics/">Simulation and Estimation Diagnostics</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Basics</li><li><a href>Defining NLME Models</a></li></ul><a class="edit-page" href="https://github.com/PumasAI/PumasDocs.jl/blob/master/docs/src/basics/models.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Defining NLME Models</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Defining-NLME-Models-1" href="#Defining-NLME-Models-1">Defining NLME Models</a></h1><p>Nonlinear Mixed Effects (NLME) models are central to pharmacometric modeling. A model is the structure which includes the dynamical equations, the structure of the parameters (the names, domains, and constraints), and the observables. This page documents the two interfaces for defining a NLME model:</p><ol><li>The <code>@model</code> Domain-Specific Language (DSL) is for simplified definitions of NLME models with standard naming assumptions.</li><li>The function-based interface is for defining NLME models via Julia functions, allowing for full flexibility and efficiency.</li></ol><p>We recommend that all users start with the <code>@model</code> DSL, and computationally-inclined pharmacometricians who are comfortable with more programmatic development (or those who need the enlarged feature-set) may wish to utilize the function-based interface. Both interface with the proceeding simulation and estimation tooling in the same manner.</p><h3><a class="nav-anchor" id="Quick-Note-on-Probability-Distributions-1" href="#Quick-Note-on-Probability-Distributions-1">Quick Note on Probability Distributions</a></h3><p>Many of the NLME model definition portions require the specification of probability distributions. The distributions in Pumas are defined by the <a href="https://juliastats.github.io/Distributions.jl/stable/">Distributions.jl</a> library. All of the Distributions.jl <code>Distribution</code> types are able to be used throughout the Pumas model definitions. Multivariate domains defines values which are vectors while univariate domains define values which are scalars. For the full documentation of the <code>Distribution</code> types, please see <a href="https://juliastats.github.io/Distributions.jl/stable/">the Distributions.jl documentation</a></p><h2><a class="nav-anchor" id="The-@model-DSL-1" href="#The-@model-DSL-1">The <code>@model</code> DSL</a></h2><p>The <code>@model</code> DSL allows for simplified NLME definitions. This interface can also be used to define simpler linear and probability distribution models without the mixed effects. The components of a model (in order) are as follows:</p><ol><li><code>@param</code> defines the fixed effects and other parameters of the model, along with the domains and constraints on the parameters (for estimation).</li><li><code>@random</code> (optional) defines the random effects via probability distributions on the parameters.</li><li><code>@covariates</code> (optional) defines the covariates of the model.</li><li><code>@pre</code> defines the pre-processing collation between the parameters, random effects, and covariates for the definition of the dynamical parameters.</li><li><code>@vars</code> (optional) defines aliases that can be used in the proceeding blocks.</li><li><code>@init</code> (optional) defines the initial conditions for the dynamical model.</li><li><code>@dynamics</code> (optional) defines the dynamical model, either by its differential equation or its analytical solution.</li><li><code>@derived</code> defines the derived observables from the dynamical model&#39;s solution, including the error distributions.</li><li><code>@observed</code> (optional) defines post-processing on the observables sampled from the error distributions.</li></ol><p>All of these blocks allow the use of Julia functions defined outside of the macro.</p><h3><a class="nav-anchor" id="@param:-Parameters-1" href="#@param:-Parameters-1"><code>@param</code>: Parameters</a></h3><p>This block defines the structure of the parameters within the model. Parameters are defined by an <code>in</code> (or ∈, written via \in) statement specifying the <code>Domain</code> type that the parameter  resides in. For example, to specify θ as a real scalar, one would write:</p><pre><code class="language-julia">θ in RealDomain()</code></pre><pre><code class="language-julia">θ ∈ RealDomain()</code></pre><p>Many of these domains allow specifying bounds, for example, we can specify θ as a scalar between 0.0 and 1.0 via:</p><pre><code class="language-julia">θ ∈ RealDomain(lower=0.0, upper=1.0)</code></pre><p>For the full specifications of the domain types, please the <a href="../../model_components/domains/#Domains-1">Domains</a> page. Additionally, parameters can be defined via a probability distributions, in which case the values are defined via <code>~</code>. For example, we can say that θ comes from a standard normal distribution via:</p><pre><code class="language-julia">θ ~ Normal(0,1)</code></pre><p>Implicitly, the domain of θ is the support of the probability distributions. Thus for this example, the domain of θ is the same as <code>RealDomain()</code>. However, if the value of θ is not specified in the parameter list during simulation, θ will automatically be sampled from this distribution. Additionally, this probability distribution can be thought of as the prior distribution on θ and is utilized in Bayesian estimation routines.</p><p>The parameters block is a list of parameter domain definitions, for example:</p><pre><code class="language-julia">@param begin
    θ ∈ VectorDomain(3, lower=[0.0,0.0,0.0], upper=[20.0,20.0,20.0])
    Ω ∈ PSDDomain(2)
    Σ ∈ ConstDomain(0.1)
end</code></pre><p>Note that this block is for the structure and not the values of the parameters. The values are defined when invoking simulation or estimation so that they can more easily be modified.</p><h3><a class="nav-anchor" id="@random:-Random-Effects-1" href="#@random:-Random-Effects-1"><code>@random</code>: Random Effects</a></h3><p>This block defines the structure of the random effect sampling process. These structures are given by <code>~</code> statements to probability distributions which may be defined by parameters. For example, if Ω is a positive-definite matrix, we can specify that η is defined as a sample from a multivariate normal distribution with covariance matrix Ω via the statement:</p><pre><code class="language-julia">η ~ MVNormal(Ω)</code></pre><p>The <code>@random</code> block is defined by a list of such statements, like:</p><pre><code class="language-julia">@random begin
   η ~ MVNormal(Ω)
   κ ~ MVNormal(Π)
end</code></pre><h3><a class="nav-anchor" id="@covariates:-Covariates-1" href="#@covariates:-Covariates-1"><code>@covariates</code>: Covariates</a></h3><p>The <code>@covariates</code> block defines the names of the covariates. This is a simply a list of names, such as:</p><pre><code class="language-julia">@covariates wt sex height</code></pre><p>or</p><pre><code class="language-julia">@covariates begin
   wt
   sex
   height
end</code></pre><p>Covariates in the model match the structures they inherit from the data defined in the <code>Subject</code>.</p><h3><a class="nav-anchor" id="@pre:-Pre-Processing-1" href="#@pre:-Pre-Processing-1"><code>@pre</code>: Pre-Processing</a></h3><p>The <code>@pre</code> block defines the pre-processing collation for the definition of the dynamical parameters from the fixed and random effects. These values are specified by equality (<code>=</code>) statements. For example, one may specify that the parameter <code>Ka</code> is defined by the first value of θ and the first value of η, we can write the command:</p><pre><code class="language-julia">Ka = θ[1] * exp(η[1])</code></pre><p>Standard Julia syntax can be used within this block, any externally defined Julia functions can be used in this block, and the resulting variables can be any Julia type. One consequence of allowing these values to be any Julia type is that the pre-processed variables can be Julia functions. For example, we can define <code>Ka</code> as a time-dependent function by using Julia&#39;s <a href="https://docs.julialang.org/en/v1/manual/functions/index.html#man-anonymous-functions-1">anonymous function syntax</a>:</p><pre><code class="language-julia">Ka = t -&gt; t*θ[1]</code></pre><p><code>@pre</code> is defined by a list of such equality statements, for example:</p><pre><code class="language-julia">@pre begin
    Ka     = θ[1]
    CL      = θ[2]*exp(η[1])
    Vc      = t -&gt; t*θ[3]*exp(η[2])
end</code></pre><h4><a class="nav-anchor" id="Dosing-Control-Parameters-1" href="#Dosing-Control-Parameters-1">Dosing Control Parameters</a></h4><p>Special parameters, such as <code>lag</code>, are used to control the internal event handling (dosing) system. For more information on these parameters, see the <a href="../../model_components/dosing_control/#Dosing-Control-Parameters-(DCP)-1">Dosing Control Parameters (DCP)</a> page.</p><h3><a class="nav-anchor" id="@vars:-Variable-Aliases-1" href="#@vars:-Variable-Aliases-1"><code>@vars</code>: Variable Aliases</a></h3><p>The <code>@vars</code> block defines aliases which can be used in the proceeding blocks. In the <code>@init</code> and <code>@dynamics</code> blocks the statement is interpreted to take place at the current solver time, while in the <code>@derived</code> and <code>@observed</code> the values alias the time series along the solution. An alias is defined by an equality (<code>=</code>) statement. For example, to define <code>conc</code> as an alias for the dynamical variable <code>Central</code> divided by the parameter <code>V</code>, we would write the equation:</p><pre><code class="language-julia">@vars begin
   conc = Central / V
end</code></pre><p>Note that the variable <code>t</code> for time can be utilized within these expressions. Inside the <code>@init</code> and <code>@dynamics</code> blocks it stands for the solver time, while in the <code>@derived</code> and <code>@observed</code> blocks it stands for the current time in the time series. For example,</p><pre><code class="language-julia">@vars begin
   conc_t = conc / t
end</code></pre><p>is the value of <code>conc</code> divided by <code>t</code>.</p><p>The <code>@vars</code> block is defined by a list of such equality statements, such as:</p><pre><code class="language-julia">@vars begin
    conc   = Central / V
    conc_t = conc / t
end</code></pre><p>Note that the special value <code>:=</code> can be used to define intermediate statements that will not be carried outside of the block.</p><h3><a class="nav-anchor" id="@init:-Initial-Conditions-1" href="#@init:-Initial-Conditions-1"><code>@init</code>: Initial Conditions</a></h3><p>This block defines the initial conditions of the dynamical model in terms of the parameters, random effects, and pre-processed variables. It is defined by a series of equality (<code>=</code>) statements. For example, to set the initial condition of the <code>Response</code> dynamical variable to be the value of the 5th term of the parameter θ, we would use the syntax:</p><pre><code class="language-julia">Response = θ[5]</code></pre><p>The block is then given by a sequence of such statements, such as:</p><pre><code class="language-julia">@init begin
   Response1 = θ[5]
   Response2 = Kin/Kout
end</code></pre><p>where <code>Kin</code> and <code>Kout</code> were defined earlier in the <code>@pre</code> block.</p><p>Any variable omitted from this block is given the default initial condition of 0. If the block is omitted, then all dynamical variables are initialized at 0.</p><p>Note that the special value <code>:=</code> can be used to define intermediate statements that will not be carried outside of the block.</p><h3><a class="nav-anchor" id="@dynamics:-The-Dynamical-Model-1" href="#@dynamics:-The-Dynamical-Model-1"><code>@dynamics</code>: The Dynamical Model</a></h3><p>The <code>@dynamics</code> block defines the nonlinear function from the parameters to the derived variables via a dynamical (differential equation) model. It can currently be specified either by an analytical solution type or via an ordinary differential equation (ODE) (for more types of differential equations, please see the function-based interface).</p><p>The analytical solutions are defined in the <a href="../../model_components/dynamical_types/#Dynamical-Problem-Types-1">Dynamical Problem Types</a> page and can be invoked via the name. For example,</p><pre><code class="language-julia">@dynamics OneCompartmentModel</code></pre><p>defines the dynamical model as the <code>OneCompartmentModel</code>.</p><p>For a system of ODEs, the dynamical variables are defined by their derivative expression. A derivative expression is given by a variable&#39;s derivative (specified by <code>&#39;</code>) and an equality (<code>=</code>). For example, the following defines the value <code>Depot</code> by it&#39;s ODE:</p><pre><code class="language-julia">Depot&#39; = -Ka*Depot</code></pre><p>where <code>Ka</code> was defined in the <code>@pre</code> block. Variable aliases defined in the <code>@vars</code> are accessible in this block. Additionally, the variable <code>t</code> is reserved for the solver time. For example, if <code>Ka(t)</code> was defined as a function in the <code>@pre</code> block, then the value of <code>Ka</code> at solver time can be utilized in the derivative expression via:</p><pre><code class="language-julia">Depot&#39; = -Ka(t)*Depot</code></pre><p>This is utilized for handling constructs such as time-varying covariates.</p><p>Note that any Julia function defined outside of the <code>@model</code> block can be invoked in the <code>@dynamics</code> block.</p><h3><a class="nav-anchor" id="@derived:-Derived-Observables-1" href="#@derived:-Derived-Observables-1"><code>@derived</code>: Derived Observables</a></h3><p>The <code>@derived</code> block defines the derived observables of the NLME model. They can be defined by any combination of the parameters, random effects, covariates, preprocessed variables, dynamical variables, and aliases. In this block, the value <code>t</code> is the time series which matches the array given in <code>subject.time</code>. The dynamical variables are an array which matches <code>t</code> in size, where <code>var[i]</code> is the value of the dynamical variable at time <code>t[i]</code>. Any aliases of a dynamical variable are also a time series.</p><p>Observables can either be defined by equality statements <code>=</code> or by a distribution with <code>~</code>. For example, the equality statement</p><pre><code class="language-julia">conc = @. Central / V</code></pre><p>defines an array <code>conc</code> to be output from the model. Notice that we used Julia&#39;s <a href="https://docs.julialang.org/en/v1/manual/arrays/index.html#Broadcasting-1">broadcast syntax</a> (<code>@.</code>) for specifying that every value of Central is to be divided by <code>V</code>. Note that any standard Julia syntax (and externally defined functions) are allowed in this block.</p><p>Error models are defined by <code>~</code> statements to probability distributions. For example, the following defines a time series of Normal distributions centered around the value of <code>conc</code> with a variance dependent on <code>conc</code> and <code>ϵ</code>:</p><pre><code class="language-julia">@derived begin
   dv ~ @. Normal(conc,conc*ϵ)
end</code></pre><p>The likelihood of these distributions are utilized in the maximum likelihood and Bayesian estimation routines. Additionally, values in the <code>@observed</code> block are sampled from these error models.</p><p>The <code>@derived</code> block is defined by a list of these expressions, for example:</p><pre><code class="language-julia">@derived begin
   conc = @. Central / V
   dv ~ @. Normal(conc,conc*ϵ)
end</code></pre><p>Note that the special value <code>:=</code> can be used to define intermediate statements that will not be carried outside of the block.</p><p>As a convenience, tie-ins with the included Noncompartmental Analysis (NCA) suite are given with via the <code>@nca</code> macro. For example, we can perform an NCA analysis via:</p><pre><code class="language-julia">@derived begin
   conc = @. Central / V
   dv ~ @. Normal(conc,conc*ϵ)
   nca := @nca conc
end</code></pre><p>to build an <code>NCASubject</code> using the time series given by the derived or dynamical variable <code>conc</code>. Once defined, the functionality of the <a href="../nca/#Noncompartmental-Analysis-(NCA)-1">Noncompartmental Analysis (NCA)</a> can be used to define derived variables via NCA diagnostics, for example:</p><pre><code class="language-julia">@derived begin
   conc = @. Central / V
   dv ~ @. Normal(conc,conc*ϵ)
   nca := @nca conc
   auc =  NCA.auc(nca)
   thalf =  NCA.thalf(nca)
   cmax = NCA.cmax(nca)
end</code></pre><p>Notice that the <code>@derived</code> block can mix values of different types (such as arrays and scalars) in the output.  </p><h3><a class="nav-anchor" id="@observed:-Sampled-Observations-1" href="#@observed:-Sampled-Observations-1"><code>@observed</code>: Sampled Observations</a></h3><p>The <code>@observed</code> block allows one to define output variables based on the sampled values from the error model. These are given by equality statements (<code>=</code>) which can utilize the parameters, random effects, covariates, dynamical variables, and any sampled derived variables. For example, if we had defined:</p><pre><code class="language-julia">@derived begin
   dv ~ @. Normal(conc,conc*ϵ)
end</code></pre><p>then we can add the simulated AUC of the concentration with the error model&#39;s stochasticity (the <code>dv</code> values of one simulation) by utilizing the NCA features from within the <code>@observed</code> block as follows:</p><pre><code class="language-julia">@observed begin
   nca := @nca dv
   sampled_auc = NCA.auc(nca)
end</code></pre><p>If no <code>@observed</code> block is specified, then the results of a simulation will simply be the derived values and the samples from the error models.</p><h2><a class="nav-anchor" id="The-PumasModel-Function-Based-Interface-1" href="#The-PumasModel-Function-Based-Interface-1">The PumasModel Function-Based Interface</a></h2><p>The <code>PumasModel</code> function-based interface for defining an NLME model is the most expressive mechanism for using Pumas and directly utilizes Julia types and functions. In fact, under the hood the <code>@model</code> DSL works by building an expression for the <code>PumasModel</code> interface! A <code>PumasModel</code> has the constructor:</p><pre><code class="language-julia">PumasModel(paramset,random,pre,init,prob,derived,observed=(col,sol,obstimes,samples,subject)-&gt;samples)</code></pre><p>Notice that the <code>observed</code> function is optional. This section describes the API of the functions which make up the <code>PumasModel</code> type. The structure closely follows that of the <code>@model</code> macro but is more directly Julia syntax.</p><h3><a class="nav-anchor" id="The-paramset-ParamSet-1" href="#The-paramset-ParamSet-1">The <code>paramset</code> ParamSet</a></h3><p>The value <code>paramset</code> is a <code>ParamSet</code> object which takes in a named tuple of <code>Domain</code> types. These <code>Domain</code> types are defined on the <a href="../../model_components/domains/#Domains-1">Domains</a> page. For example, the following is a value <code>ParamSet</code> construction:</p><pre><code class="language-julia">paramset = ParamSet((θ = VectorDomain(4, lower=zeros(4)), # parameters
              Ω = PSDDomain(2),
              Σ = RealDomain(lower=0.0),
              a = ConstDomain(0.2)))</code></pre><h3><a class="nav-anchor" id="The-random-Function-1" href="#The-random-Function-1">The <code>random</code> Function</a></h3><p>The <code>random(param)</code> function is a function on the parameters. It takes in the values from the <code>param</code> input named tuple and outputs a <code>ParamSet</code> for the random effects. For example:</p><pre><code class="language-julia">function random(p)
    ParamSet((η=MvNormal(p.Ω),))
end</code></pre><p>is a valid <code>random</code> function.</p><h3><a class="nav-anchor" id="The-pre-Function-1" href="#The-pre-Function-1">The <code>pre</code> Function</a></h3><p>The <code>pre</code> function takes in the <code>param</code> named tuple, the sampled <code>randeffs</code> named tuple, and the <code>subject</code> data and defines the named tuple of the collated preprocessed dynamical parameters. For example, the following is a valid definition of the <code>pre</code> function:</p><pre><code class="language-julia">function pre(param,randeffs,subject)
    (Σ  = param.Σ,
    Ka = param.θ[1],  # pre
    CL = param.θ[2] * ((subject.covariates.wt/70)^0.75) *
         (param.θ[4]^subject.covariates.sex) * exp(randeffs.η[1]),
    V  = param.θ[3] * exp(randeffs.η[2]))
end</code></pre><p>The output can be any valid Julia type. Notice that the covariates are specified via the <code>subject.covariates</code> field.</p><h4><a class="nav-anchor" id="Dosing-Control-Parameters-2" href="#Dosing-Control-Parameters-2">Dosing Control Parameters</a></h4><p>Special parameters in the return of the <code>pre</code> function, such as <code>lag</code>, are used to control the internal event handling (dosing) system. For more information on these parameters, see the <a href="../../model_components/dosing_control/#Dosing-Control-Parameters-(DCP)-1">Dosing Control Parameters (DCP)</a> page.</p><h3><a class="nav-anchor" id="The-init-Function-1" href="#The-init-Function-1">The <code>init</code> Function</a></h3><p>The <code>init</code> function defines the initial conditions of the dynamical variables from the collated preprocessed values <code>col</code> and the initial time point <code>t0</code>. Note that this follows the <a href="http://docs.juliadiffeq.org/latest/">DifferentialEquations.jl</a> convention, in that the initial value type defines the type for the state used in the evolution equation.</p><p>For example, the following defines the initial condition to be a vector of two zeros:</p><pre><code class="language-julia">function init(col,t0)
   [0.0,0.0]
end</code></pre><h3><a class="nav-anchor" id="The-prob-DEProblem-1" href="#The-prob-DEProblem-1">The <code>prob</code> DEProblem</a></h3><p>The <code>prob</code> is a <code>DEProblem</code> defined by <a href="http://docs.juliadiffeq.org/latest/">DifferentialEquations.jl</a>. It can be any <code>DEProblem</code>, and the choice of <code>DEProblem</code> specifies the type of dynamical model. For example, if <code>prob</code> is an <code>SDEProblem</code>, then the NLME will be defined via a stochastic differential equation, and if <code>prob</code> is a <code>DDEProblem</code>, then the NLME will be defined via a delay differential equation. For details on defining a <code>DEProblem</code>, please <a href="http://docs.juliadiffeq.org/latest/">consult the DifferentialEquations.jl documentation</a>.</p><p>Note that the timespan, initial condition, and parameters are sentinels that will be overridden in the simulation pipeline. Thus, for example, we can define <code>prob</code> as an <code>ODEProblem</code> omitting these values as follows:</p><pre><code class="language-julia">function onecompartment_f(du,u,p,t)
    du[1] = -p.Ka*u[1]
    du[2] =  p.Ka*u[1] - (p.CL/p.V)*u[2]
end
prob = ODEProblem(onecompartment_f,nothing,nothing,nothing)</code></pre><p>Notice that the parameters of the differential equation <code>p</code> is the result value <code>pre</code>.</p><h3><a class="nav-anchor" id="The-derived-Function-1" href="#The-derived-Function-1">The <code>derived</code> Function</a></h3><p>The <code>derived</code> function takes in the collated preprocessed values <code>col</code>, the <code>DESolution</code> to the differential equation <code>sol</code>, the <code>obstimes</code> set during the simulation and estimation, and the full <code>subject</code> data. The output can be any Julia type on which <code>map(f,x)</code> is defined (the <code>map</code> is utilized for the subsequent sampling of the error models). For example, the following is a valid <code>derived</code> function which outputs a named tuple:</p><pre><code class="language-julia">function derived(col,sol,obstimes,subject)
    central = sol(obstimes;idxs=2)
    conc = @. central / col.V
    dv = @. Normal(conc, conc*col.Σ)
    (dv=dv,)
end</code></pre><p>Note that probability distributions in the output have a special meaning in maximum likelihood and Bayesian estimation, and are automatically sampled to become observation values during simulation.</p><h3><a class="nav-anchor" id="The-observed-Function-1" href="#The-observed-Function-1">The <code>observed</code> Function</a></h3><p>The <code>observed</code> function takes in the collated preprocessed values <code>col</code>, the <code>DESolution</code> <code>sol</code>, the <code>obstimes</code>, the sampled derived values <code>samples</code>, and the full <code>subject</code> data. The output value is the simulation output. It can be any Julia type. For example, the following is a valid <code>observed</code> function:</p><pre><code class="language-julia">function observed(col,sol,obstimes,samples,subject)
    (obs_cmax = maximum(samples.dv),
     T_max = maximum(obstimes),
     dv = samples.dv)
end</code></pre><p>Note that if the <code>observed</code> function is not given to the <code>PumasModel</code> constructor, the default function <code>(col,sol,obstimes,samples,subject)-&gt;samples</code> which passes through the sampled derived values is used.</p><footer><hr/><a class="previous" href="../overview/"><span class="direction">Previous</span><span class="title">Overview of Pumas</span></a><a class="next" href="../doses_subjects_populations/"><span class="direction">Next</span><span class="title">Dosage Regimens, Subjects, and Populations</span></a></footer></article></body></html>
